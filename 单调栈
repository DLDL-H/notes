单调栈的应用
（解决柱状图中的最大矩形问题-leetcode-84）
首先以最大的矩形一定可以完全覆盖某一个柱为出发点，即只需要计算n个矩形的面积（每个矩形对应覆盖一个柱）进行比较即可
而该柱的高度是已知的，因此，问题的关键是求宽度
求宽度的关键是向左和向右找到最近的比目标柱高度小的柱的下标
因此适合单调栈处理

（入栈是入下标，不入高度）
柱i入栈的条件是
{
heights[i]>=heights[A]  （A为栈顶的柱）
或者栈为空
}
这样可以保证栈内的高度是非严格递增的，其目的是针对柱A可以快速找到其左边第一个比他矮的柱的下标

而
if(heights[i]<heights[A]){
则A出栈
此时要计算覆盖A的矩形的面积，根据上文可知该矩形的左边沿就是现在的栈顶（如果栈为空则为0）
而根据出栈的条件可知该矩形的右边沿就是i
因此其宽度为stk.empty()? i:(i - stk.top() -1))
这样逐一比较即可
}

PS：由于是在出栈时计算矩形的面积，因此必须让每一个元素都出栈，故在最开始的vector中在末尾添加0
